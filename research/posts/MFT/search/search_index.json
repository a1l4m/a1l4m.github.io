{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Last Two Bytes: Resident Data and Fixup Artifacts in NTFS","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The Master File Table (MFT) in NTFS plays a critical role in file storage by managing metadata and determining whether file content is stored within the MFT itself (resident data) or externally in clusters (non-resident data). Understanding the conditions that influence resident data storage is essential for digital forensics and incident response, as these conditions impact how files are structured within the NTFS file system.</p> <p>This study examines the relationship between file size, filename length, and resident data behavior, providing a structured methodology to determine the threshold at which file content transitions from resident to non-resident storage. Additionally, it was observed that when data remains resident within the MFT, a structural modification occurs within the File Record at offset <code>0x1FE</code>. This behavior may have forensic implications, particularly in file integrity verification and malware investigations.</p> <p>By understanding these patterns, forensic analysts can improve their ability to detect resident malware, reconstruct file system events, and evaluate the integrity of NTFS file records during investigations.</p> <p></p>"},{"location":"#analysis-of-resident-and-non-resident-data-in-the-ntfs-master-file-table-mft","title":"Analysis of Resident and Non-Resident Data in the NTFS Master File Table (MFT)","text":""},{"location":"#resident-data-threshold-based-on-file-size-and-filename-length","title":"Resident Data Threshold Based on File Size and Filename Length","text":"<p>The length of a filename is a critical factor in determining whether file content remains resident within the MFT. Variations in filename length directly influence the size of the <code>$File_Name</code> attribute, which, in turn, affects the available space for storing file content within the MFT. As filename length increases, additional space is occupied by the <code>$File_Name</code> attribute, reducing the amount of space available for resident data. This relationship must be carefully considered when analyzing NTFS structures in forensic investigations.</p>"},{"location":"#resident-data-behavior-for-filenames-7","title":"Resident Data Behavior for Filenames \u2264 7","text":"<ul> <li> <p>When filenames contained 7 characters or fewer, including the file extension (e.g., <code>777.txt</code>, <code>77.txt</code>, <code>7.txt</code>), the <code>$File_Name</code> attribute length was measured as 0x68 bytes.</p> <p></p> </li> <li> <p>It was observed that when the file size remained \u2264 696 bytes, the file content was stored resident within the MFT.</p> </li> <li>However, when the file size increased by just one additional byte (697 bytes total), the data became non-resident, causing the file size on disk to expand to 4 KB, despite the actual file content being only 697 bytes.</li> <li> <p>When the filename exceeded 7 characters, the <code>$File_Name</code> attribute length increased to 0x70 bytes, requiring a smaller file size (below 696 bytes) to maintain resident storage.</p> <p></p> </li> </ul>"},{"location":"#resident-data-behavior-for-filenames-between-8-and-11-characters","title":"Resident Data Behavior for Filenames Between 8 and 11 Characters","text":"<ul> <li> <p>The file name attribute length was measured as 0x70 bytes when using a 8\u202611 characters, including the file extension (e.g., <code>8888.txt</code>, <code>88888.txt</code>, <code>888888.txt</code>).</p> <p></p> </li> <li> <p>To determine the maximum resident data size for filenames between 8 and 11 characters, the difference in attribute length was calculated:</p> <ul> <li>0x70 - 0x68 = 0x8  (in decimal: 8 bytes reduction in available resident space).</li> <li>The adjusted resident data limit becomes 688 bytes instead of 696 bytes. (696-8=688)</li> </ul> </li> <li>When filenames ranged between 7 and 11 characters, file content remained resident up to 688 bytes.</li> <li> <p>However, when filenames exceeded 11 characters, data became non-resident, even if the file size was within the expected resident threshold.</p> <p></p> </li> </ul>"},{"location":"#resident-data-behavior-for-filenames-longer-than-11-characters","title":"Resident Data Behavior for Filenames Longer Than 11 Characters","text":"<ul> <li> <p>When filenames exceeded 11 characters, the <code>$File_Name</code> attribute length increased to 0x78 bytes.</p> <p></p> </li> <li> <p>Applying the same methodology, the reduction in available resident space is:</p> <ul> <li>0x78 - 0x68 = 0x10 bytes (in decimal: 16 bytes reduction in available resident space).</li> <li>The new maximum resident data size is 680 bytes. (696-16 = 680)</li> </ul> <p>Note</p> <p>This pattern was expected to remain consistent; however, an issue arose due to Microsoft\u2019s definition of Long File Names (LFN). So it worked for 12 characters but not 13 and above even though they both have the same <code>$File_Name</code> attribute length which is **0x78.</p> <p></p> </li> </ul> <p>All tests were conducted with filename extensions included (We considered the dot <code>.</code> as a character). If the extension is removed, the results differ, and this aspect will be discussed in the following section.</p>"},{"location":"#long-filenames-longer-than-12-characters-and-their-effect-on-resident-data","title":"Long Filenames Longer Than 12 Characters, and Their Effect on Resident Data","text":"<ul> <li> <p>When filenames contained \u2265 13 characters (including the extension) or \u2265 9 characters (excluding the extension), they were observed to be treated as Long File Names (LFN) by the MFT.</p> <ul> <li>Explanation: NTFS defines long filenames as those exceeding 8 characters plus a 3-character extension (e.g., <code>\"SANS12345.TXT\"</code>).</li> </ul> <p></p> </li> <li> <p>When a filename is classified as an LFN, additional content is written to the <code>$File_Name</code> attribute, increasing its size and altering the expected pattern.</p> <p>Info</p> <p>The presence of variable-length long filenames modifies the content size of the <code>$File_Name</code> attribute, which subsequently impacts the available space for resident data.</p> </li> </ul> <p></p> <ul> <li> <p>Notice the size of the content = 0x5A  and File is treated as Long File Name.</p> <p>Info</p> <p>As a result, no consistent pattern could be established for predicting the maximum resident data size when filenames exceeded the long filename threshold.</p> </li> </ul>"},{"location":"#file-record-modifications-when-data-is-resident-important","title":"File Record Modifications When Data Is Resident [Important]","text":"<p>A critical forensic artifact was identified when analyzing resident data storage in NTFS. When file content remains resident within the Master File Table (MFT), a modification occurs in the File Record structure at offset <code>0x1FE</code>. This offset corresponds to 510 bytes, which is less than the sector size (512 bytes) by 2 bytes.</p> <p>Key Observations:</p> <ul> <li> <p>The 2 bytes at <code>0x1FE</code> are replaced with a fixup value from the Fixup Array (USA) as part of NTFS's Update Sequence Number (USN) Fixup process. The original 2 bytes from <code>0x1FE</code> are stored in the Fixup Array at <code>0x32</code> for integrity verification during read operations.</p> <p></p> <p></p> </li> </ul> <p>Reason for MFT Modification at Offset 0x1FE:</p> <p>The observed behavior is a direct result of NTFS's Update Sequence Number (USN) Fixup mechanism. This mechanism is designed to protect the integrity of critical file system structures, such as the MFT, by ensuring that sector boundaries are properly validated during disk read/write operations.</p> <p>When a file record is resident within the MFT, the last two bytes of each <code>512-byte</code> sector (i.e., 0x1FE in the first sector) must be protected against corruption. To achieve this, NTFS replaces these bytes with a fixup value and stores the original bytes in the Fixup Array.</p> <p>How Fixup Values Work:</p> <p>The fixup process follows these steps:</p> <ol> <li>NTFS assigns a Fixup Value<ul> <li>At the start of an MFT record, NTFS maintains an Update Sequence Number (USN), which increments with each modification.</li> <li>This value is stored at a predefined location, typically within the Fixup Array (USA).</li> </ul> </li> <li>Overwriting the Last Two Bytes<ul> <li>The last two bytes of each sector (e.g., <code>0x1FE</code> for the first sector) are replaced with the fixup value.</li> <li>The original bytes are saved in the Fixup Array for later recovery.</li> </ul> </li> <li> <p>Integrity Check on Read Operations</p> <ul> <li>When the file system reads the MFT record, it checks whether the last two bytes of each sector match the stored fixup value.</li> <li>If they match, NTFS restores the original bytes from the Fixup Array.</li> <li>If they do not match, NTFS detects corruption and prevents the use of the damaged record.</li> </ul> <p>Note</p> <p>All addresses are relative to the start of the File Record</p> </li> </ol>"},{"location":"#implications-for-digital-forensics-and-malware-analysis","title":"Implications for Digital Forensics and Malware Analysis","text":"<ul> <li>The modification of offset <code>0x1FE</code> when storing resident data could have implications for file integrity verification and malware investigations.</li> <li>If a file contains malicious code as resident data, this behavior may interfere with forensic procedures that rely on static file hashing, as the altered MFT structure may affect hash calculations and file integrity verification.</li> <li>This could present a challenge when using file hashes as Indicators of Compromise (IOCs) in threat hunting and digital forensics investigations.</li> </ul>"},{"location":"#key-takeaways","title":"Key Takeaways","text":"<ul> <li>The length of a filename influences whether file content remains resident within the MFT by modifying the <code>$File_Name</code> attribute length.</li> <li>The transition from resident to non-resident data occurs at different file size thresholds depending on filename length.</li> <li>When filenames exceed 12 characters, the presence of long filenames (LFN) disrupts the observed pattern, making resident storage behavior less predictable.</li> <li>A forensic artifact was identified in which offset <code>0x1FE</code> is modified when file content is stored as resident data, potentially affecting forensic hashing and malware detection.</li> </ul>"},{"location":"#conclusion","title":"Conclusion","text":"<p>This study highlights key findings regarding the relationship between file size, filename length, and MFT resident data storage behavior. A clear correlation has been established between filename length and the available resident data space within the MFT, demonstrating how filenames influence the transition from resident to non-resident storage. However, filename attribute is just one of several factors affecting the size of resident data. Our analysis considers only the creation of a basic file, not including other cases such as data compression and encryption, which introduce additional attributes that can impact data residency. The identification of modifications at offset <code>0x1FE</code> presents a potential forensic artifact that could be leveraged for detecting resident malware and analyzing NTFS anomalies, as many people may extract resident data incorrectly. These findings emphasize the importance of considering filename length and other influencing factors during forensic investigations, as even minor changes in naming conventions or storage attributes can significantly impact data residency within NTFS file structures.</p>"},{"location":"#credits","title":"Credits","text":"<p>Khaled Allam - Linkedin</p> <p>Ahmed Mahmoud Fathy - LinkedIn</p>"}]}